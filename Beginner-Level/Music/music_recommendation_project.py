# -*- coding: utf-8 -*-
"""MUSIC_RECOMMENDATION_PROJECT.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/DevlinaPal/LGMVIP-DataScience/blob/main/Beginner-level/MUSIC%20RECOMMENDATION/MUSIC_RECOMMENDATION_PROJECT.ipynb

NAME- RAJ KAMAL SHAKYA

LGM-VIP INTERNSHIP

 BEGINNER LEVEL TASK -3

 Music Recommendation

1. IMPORT LIBRARY
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings("ignore")

"""2. LOADING DATA"""

df1 = pd.read_csv("songs.csv")
df2 = pd.read_csv("users.csv")

"""3. UNDERSTANDING THE DATA"""

df1.head()

df2.head()

df1.info()

df1.describe()

df2.info()

df2.describe()

"""4. MODIFYING DATASET COLUMNS """

df1["year"] = df1["year"].astype('Int64')
df1.rename(columns={"release": "album", "artist_name": "artist"}, inplace=True)
df1.head()

df2["listen_count"] = df2["listen_count"].astype('Int64')
df2.head()

"""5. MERGING THE TWO DATASETS INTO ONE DATASET"""

df = pd.merge(df2, df1.drop_duplicates(["song_id"]), on='song_id', how='left')
df['song'] = df['artist'] + ' - ' + df['title']
df = df.drop(['title'], axis=1)
df = df.head(50000)
df.head()

"""6. EXPLORATORY DATA ANALYSIS"""

print("Number of entries in each column:\n")
df.count()

print("Number of unique users: ", df.user_id.nunique(dropna = True))
print("Number of artists: ", df.artist.nunique(dropna=True))
print("Number of songs: ", df.song_id.nunique(dropna=True))

plt.figure(figsize=(15, 10))
sns.set(rc={'axes.facecolor':'pink', 'figure.facecolor':'pink'})
sns.countplot(x='year', data=df[-(df['year']==0)], color="red")
plt.xticks(rotation=90)
plt.title("No. of Songs per Year", fontsize=20)
plt.xlabel("Year", fontsize=15)
plt.ylabel("Count", fontsize=15)
plt.show()

plt.figure(figsize=(10,10))
sns.set(rc={'axes.facecolor':'pink', 'figure.facecolor':'pink'})
sns.barplot(x = (df['song'].value_counts()[:10].values), y = (df['song'].value_counts()[:10].index), color="red")
plt.title('Most Popular Songs', fontsize=20)
plt.xlabel('Listeners', fontsize=15)
plt.ylabel('Songs', fontsize=15)
plt.show()

plt.figure(figsize=(20,10))
sns.set(rc={'axes.facecolor':'pink', 'figure.facecolor':'pink'})
sns.barplot(x = (df['artist'].value_counts()[:10].index), y = (df['artist'].value_counts()[:10].values), color="red")
plt.title('No. of Listeners per Artist', fontsize=20)
plt.xlabel('Artist', fontsize=17)
plt.ylabel('Listeners', fontsize=17)
plt.show()

"""7. BUILDING A RECOMMENDATION ENGINE"""

class Engine():
    def __init__(self, data, user_id, song):
        self.data = data
        self.user_id = user_id
        self.song = song
        self.glcm = None
        
    def get_song_history(self, user):
        user_data = self.data[self.data[self.user_id] == user]
        return list(user_data[self.song].unique())
        
    def get_users(self, item):
        item_data = self.data[self.data[self.song] == item]
        return set(item_data[self.user_id].unique())
        
    def get_all_songs(self):
        return list(self.data[self.song].unique())
        
    def get_glcm(self, user_songs, all_songs):
        users = []        
        for i in range(0, len(user_songs)):
            users.append(self.get_users(user_songs[i]))   
        glcm = np.matrix(np.zeros(shape=(len(user_songs), len(all_songs))), float)

        for i in range(0,len(all_songs)):
            songs_i_data = self.data[self.data[self.song] == all_songs[i]]
            users_i = set(songs_i_data[self.user_id].unique())
            
            for j in range(0,len(user_songs)):           
                users_j = users[j]
                users_intersection = users_i.intersection(users_j)
               
                users_union = users_i.union(users_j)
                glcm[j,i] = float(len(users_intersection))/float(len(users_union))

        return glcm

    def generate_recommendations(self, user, glcm, all_songs, user_songs):
        sim_scores = glcm.sum(axis=0)/float(glcm.shape[0])
        sim_scores = np.array(sim_scores)[0].tolist()
 
        sort_index = sorted(((e,i) for i,e in enumerate(list(sim_scores))), reverse=True)
        columns = ['UserID', 'Song', 'Score', 'Rank']
        df = pd.DataFrame(columns=columns)
         
        rank = 1 
        for i in range(0,len(sort_index)):
            if ~np.isnan(sort_index[i][0]) and all_songs[sort_index[i][1]] not in user_songs and rank <= 10:
                df.loc[len(df)]=[user,all_songs[sort_index[i][1]],sort_index[i][0],rank]
                rank = rank+1
        
        print("Music Recommendations: \n")
        return df.drop(['UserID'], axis=1)

    def get_recommendations(self, user):
        user_songs = self.get_song_history(user)    
        all_songs = self.get_all_songs()
        glcm = self.get_glcm(user_songs, all_songs)
        return self.generate_recommendations(user, glcm, all_songs, user_songs)

    def get_similar_songs(self, item_list):
        user_songs = item_list
        all_songs = self.get_all_songs()
        glcm = self.get_glcm(user_songs, all_songs)
        return self.generate_recommendations("", glcm, all_songs, user_songs)

"""8. GETTING SONG HISTORY OF USER AT INDEX 1001"""

eng = Engine(df, 'user_id', 'song')
song_history = eng.get_song_history(df['user_id'][1001])

print("User Song History: \n")
for song in song_history:
  print(song)

"""9. GETTING RECOMMENDATIONS FOR USER AT INDEX 1001"""

eng.get_recommendations(df['user_id'][1001])

"""RETRIEVING SIMILAR SONGS WITH RESPECT TO A SPECIFIC SONG"""

eng.get_similar_songs(['La Roux - Bulletproof'])